import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { FontLoader } from 'three/addons/loaders/FontLoader.js';
import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';

// Elementos do DOM
const previewContainer = document.getElementById('three-preview-container');
const textInput = document.getElementById('text-input');
const textColorInput = document.getElementById('text-color');
const textDepthInput = document.getElementById('text-depth');
const textDepthValueSpan = document.getElementById('text-depth-value');
const addBaseCheckbox = document.getElementById('add-base');
const addBackgroundPanelCheckbox = document.getElementById('add-background-panel');
const previewButton = document.getElementById('preview-button');
const generateGlbButton = document.getElementById('generate-glb-button');
const loadingOverlay = document.querySelector('.loading-overlay');

// Variáveis da cena 3D
let scene, camera, renderer, controls;
let currentTextMesh, baseMesh, backgroundPanelMesh;
let loadedFont = null;
let updateTimeout = null;

// Fontes alternativas (fallback)
const FONT_URL = 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r165/examples/fonts/helvetiker_regular.typeface.json';

// Funções auxiliares
function showLoading(message = "") {
    loadingOverlay.classList.remove('hidden');
    if (message) {
        loadingOverlay.querySelector('p').textContent = message;
    }
}

function hideLoading() {
    loadingOverlay.classList.add('hidden');
}

function showNotification(message, type = "success") {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    document.body.appendChild(notification);
    setTimeout(() => notification.remove(), 5000);
}

async function loadFont() {
    if (loadedFont) return loadedFont;
    
    return new Promise((resolve, reject) => {
        showLoading("Carregando fonte 3D...");
        
        const fontLoader = new FontLoader();
        fontLoader.load(
            FONT_URL,
            (font) => {
                loadedFont = font;
                hideLoading();
                resolve(font);
            },
            undefined,
            (error) => {
                hideLoading();
                console.error("Erro ao carregar fonte:", error);
                showNotification("Erro ao carregar fonte 3D", "error");
                reject(error);
            }
        );
    });
}

function addLights() {
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight1.position.set(5, 10, 7);
    directionalLight1.castShadow = true;
    directionalLight1.shadow.mapSize.width = 1024;
    directionalLight1.shadow.mapSize.height = 1024;
    scene.add(directionalLight1);
    
    const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight2.position.set(-5, 5, -5);
    scene.add(directionalLight2);
}

function setupEventListeners() {
    textInput.addEventListener('input', () => {
        clearTimeout(updateTimeout);
        updateTimeout = setTimeout(updatePreview, 300);
    });
    
    textColorInput.addEventListener('input', updatePreview);
    
    textDepthInput.addEventListener('input', () => {
        textDepthValueSpan.textContent = textDepthInput.value;
        clearTimeout(updateTimeout);
        updateTimeout = setTimeout(updatePreview, 300);
    });
    
    addBaseCheckbox.addEventListener('change', updatePreview);
    addBackgroundPanelCheckbox.addEventListener('change', updatePreview);
    previewButton.addEventListener('click', updatePreview);
    generateGlbButton.addEventListener('click', generateGLB);
    
    window.addEventListener('resize', () => {
        camera.aspect = previewContainer.clientWidth / previewContainer.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(previewContainer.clientWidth, previewContainer.clientHeight);
    });
}

function cleanupScene() {
    const objectsToRemove = [];
    
    if (currentTextMesh) {
        objectsToRemove.push(currentTextMesh);
        currentTextMesh = null;
    }
    
    if (baseMesh) {
        objectsToRemove.push(baseMesh);
        baseMesh = null;
    }
    
    if (backgroundPanelMesh) {
        objectsToRemove.push(backgroundPanelMesh);
        backgroundPanelMesh = null;
    }
    
    objectsToRemove.forEach(obj => {
        scene.remove(obj);
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) {
            if (Array.isArray(obj.material)) {
                obj.material.forEach(m => m.dispose());
            } else {
                obj.material.dispose();
            }
        }
    });
}

// Função principal para atualizar a visualização
async function updatePreview() {
    if (!loadedFont) {
        console.warn("Fonte ainda não carregada");
        return;
    }
    
    showLoading("Atualizando visualização...");
    
    try {
        cleanupScene();
        
        const inputText = textInput.value.trim() || "3D TEXT";
        const textColor = new THREE.Color(textColorInput.value);
        const textDepth = parseFloat(textDepthInput.value);
        
        // Criar texto 3D
        const textMaterial = new THREE.MeshStandardMaterial({ 
            color: textColor,
            roughness: 0.3,
            metalness: 0.8
        });
        
        const textGeometry = new TextGeometry(inputText, {
            font: loadedFont,
            size: 1,
            height: textDepth,
            curveSegments: 12,
            bevelEnabled: true,
            bevelThickness: 0.05,
            bevelSize: 0.02,
            bevelSegments: 4
        });
        
        textGeometry.computeBoundingBox();
        const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
        const textHeight = textGeometry.boundingBox.max.y - textGeometry.boundingBox.min.y;
        
        currentTextMesh = new THREE.Mesh(textGeometry, textMaterial);
        currentTextMesh.castShadow = true;
        
        // POSICIONAMENTO CORRIGIDO - TEXTO SOBRE A BASE
        const baseHeight = addBaseCheckbox.checked ? 0.2 : 0;
        currentTextMesh.position.set(
            -textWidth / 2,  // Centraliza horizontalmente
            baseHeight,      // Coloca sobre a base (0.2) ou no chão (0)
            0
        );
        
        scene.add(currentTextMesh);
        
        // Adicionar base (ajustada para o tamanho do texto)
        if (addBaseCheckbox.checked) {
            const baseGeometry = new THREE.BoxGeometry(
                textWidth + 0.5,  // Largura com margem
                0.2,              // Altura fixa
                textDepth * 3      // Profundidade proporcional
            );
            
            const baseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x555555,
                roughness: 0.7,
                metalness: 0.2
            });
            
            baseMesh = new THREE.Mesh(baseGeometry, baseMaterial);
            baseMesh.position.set(
                0,                // Centralizada no X
                -0.1,             // Metade da altura para ficar alinhada
                0                 // Mesma posição Z do texto
            );
            baseMesh.receiveShadow = true;
            scene.add(baseMesh);
        }
        
        // Adicionar painel de fundo (opcional)
        if (addBackgroundPanelCheckbox.checked) {
            const panelGeometry = new THREE.PlaneGeometry(8, 5);
            const panelMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x444444, 
                side: THREE.DoubleSide,
                roughness: 0.8,
                metalness: 0.1
            });
            
            backgroundPanelMesh = new THREE.Mesh(panelGeometry, panelMaterial);
            backgroundPanelMesh.position.set(0, 1.5, -3);
            backgroundPanelMesh.receiveShadow = true;
            scene.add(backgroundPanelMesh);
        }
        
        // Atualizar alvo da câmera para o centro do texto
        if (currentTextMesh) {
            const textCenterY = (textHeight / 2) + currentTextMesh.position.y;
            controls.target.set(0, textCenterY, 0);
        }
        
    } catch (error) {
        console.error("Erro ao atualizar visualização:", error);
        showNotification("Erro ao gerar visualização", "error");
    } finally {
        hideLoading();
    }
}

// Função para gerar e baixar o arquivo GLB
async function generateGLB() {
    if (!currentTextMesh) {
        showNotification("Nenhum texto para exportar!", "error");
        return;
    }
    
    showLoading("Gerando arquivo GLB...");
    generateGlbButton.disabled = true;
    
    try {
        const exporter = new GLTFExporter();
        const exportGroup = new THREE.Group();
        
        exportGroup.add(currentTextMesh.clone());
        
        if (addBaseCheckbox.checked && baseMesh) {
            exportGroup.add(baseMesh.clone());
        }
        
        if (addBackgroundPanelCheckbox.checked && backgroundPanelMesh) {
            exportGroup.add(backgroundPanelMesh.clone());
        }
        
        const glb = await new Promise((resolve, reject) => {
            exporter.parse(
                exportGroup,
                resolve,
                reject,
                {
                    binary: true,
                    onlyVisible: true,
                    trs: false
                }
            );
        });
        
        const blob = new Blob([glb], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        
        let fileName = textInput.value.trim() || 'texto_3d';
        fileName = fileName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
        a.download = `${fileName}.glb`;
        
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        setTimeout(() => URL.revokeObjectURL(url), 100);
        
        showNotification("Arquivo GLB gerado com sucesso!", "success");
        
    } catch (error) {
        console.error("Erro ao gerar GLB:", error);
        showNotification("Falha ao gerar arquivo GLB", "error");
    } finally {
        generateGlbButton.disabled = false;
        hideLoading();
    }
}

// Função de animação
function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
}

// Inicialização da aplicação
async function init() {
    showLoading("Inicializando visualizador 3D...");
    
    try {
        // Configurar cena
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x333333);
        
        // Configurar câmera
        camera = new THREE.PerspectiveCamera(
            75,
            previewContainer.clientWidth / previewContainer.clientHeight,
            0.1,
            1000
        );
        camera.position.set(0, 1.5, 5);
        camera.lookAt(0, 0.5, 0);
        
        // Configurar renderizador
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(previewContainer.clientWidth, previewContainer.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        previewContainer.appendChild(renderer.domElement);
        
        // Configurar controles
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        controls.screenSpacePanning = false;
        controls.maxPolarAngle = Math.PI / 2;
        controls.target.set(0, 0.5, 0);
        
        // Adicionar luzes
        addLights();
        
        // Carregar fonte
        await loadFont();
        
        // Configurar eventos
        setupEventListeners();
        
        // Iniciar animação
        animate();
        
        // Primeira atualização
        updatePreview();
        
    } catch (error) {
        console.error("Erro na inicialização:", error);
        showNotification("Falha ao inicializar o visualizador 3D", "error");
    } finally {
        hideLoading();
    }
}

// Iniciar quando a página carregar
window.onload = init;